#!/usr/bin/env node

let argv = {_: process.argv.slice(2)}//require('minimist')(process.argv.slice(2))
let download = require('./download')
let bitdb = require('./bitdb')

let action = argv._[0]
if (!action || action == '--help' || action == '-h') {
	let path = require('path')
	let readme = require('fs').readFileSync(path.join(path.dirname(module.filename), 'README.md'))
	process.stdout.write(readme)
	process.exit()
}
let url = argv._[1]
if (!url) { url = action; action = 'status' }
url = url.split('://')
let type, path, id, dkey
if (url[1]) {
	type = url[0].toUpperCase()
	path = url[1].split('/')
	id = path.shift()
	dkey = path.join('/')
} else {
	path = url[0]
	id = url[0]
}

if (action == 'status') {
	if (type == 'TX') {
		download.txstatus(id)
	} else if (type == 'D') {
		if (dkey) {
			download.dstatus(id, dkey)
		} else {
			download.dlog(id)
		}
	} else if (type == 'BCAT') {
		download.bcatstatus(id)
	} else if (type == 'C') {
		download.cstatus(id)
	} else if (type == 'B') {
		download.bstatus(id)
	}
} else if (action == 'quickcheck') {
	(()=>{
		if (type == 'D') {
			return download.dstatus(id, dkey, true)
		}
	})().catch(e=>{
		console.log(e)
		process.exit(-1)
	})
} else if (action == 'stream') {
	if (type == 'BCAT') {
		download.bcatstream(id, process.stdout)
	} else if (type == 'B') {
		download.bstream(id, process.stdout)
	} else if (type == 'D') {
		download.dstream(id, process.stdout, dkey)
	}
} else if (action == 'download') {
	if (type == 'D') {
		download.ddownload(id, dkey)
	} else if (type == 'BCAT') {
		download.bcatdownload(id)
	} else if (type == 'B') {
		download.bdownload(id)
	}
} else if (action == 'bitdb') {
	(async () => {
		let r = await bitdb.bitdb(JSON.parse(argv._[1]))
		console.log(JSON.stringify(r))
	})()
}


